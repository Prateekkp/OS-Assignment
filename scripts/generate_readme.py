"""
Generate the auto file listing for the repository README.md.

Usage:
    python scripts\generate_readme.py --write

By default the script prints the generated section to stdout. Use --write to update README.md in place.

This script is intentionally minimal and uses only the standard library.
"""
import argparse
import os
from pathlib import Path
import fnmatch

ROOT = Path(__file__).resolve().parents[1]
README = ROOT / "README.md"
START_MARKER = "<AUTO-GENERATED FILE LIST - START>"
END_MARKER = "<AUTO-GENERATED FILE LIST - END>"

# Files or directories to ignore (glob patterns, relative to repo root)
IGNORE = [
    "\.git",
    "venv",
    "__pycache__",
    "*.pyc",
    "scripts/generate_readme.py",
]


def should_ignore(path: Path) -> bool:
    rel = str(path.relative_to(ROOT)).replace("\\", "/")
    for pat in IGNORE:
        if fnmatch.fnmatch(rel, pat) or fnmatch.fnmatch(path.name, pat):
            return True
    return False


def build_tree(root: Path, max_depth=4) -> str:
    lines = []
    def walk(dirpath: Path, prefix: str = "", depth=0):
        if depth > max_depth:
            return
        try:
            entries = sorted(dirpath.iterdir(), key=lambda p: (p.is_file(), p.name.lower()))
        except PermissionError:
            return
        for i, p in enumerate(entries):
            if should_ignore(p):
                continue
            connector = "└── " if i == len(entries) - 1 else "├── "
            rel = str(p.relative_to(ROOT)).replace("\\", "/")
            if p.is_dir():
                lines.append(f"{prefix}{connector}{p.name}/")
                new_prefix = prefix + ("    " if i == len(entries) - 1 else "│   ")
                walk(p, new_prefix, depth + 1)
            else:
                lines.append(f"{prefix}{connector}{p.name}")
    lines.append(f"{ROOT.name}/")
    walk(root)
    return "\n".join(lines)


def generate_section() -> str:
    tree = build_tree(ROOT)
    header = "\nFiles in this repository\n\n"
    return header + "```\n" + tree + "\n```\n"


def replace_section(readme: Path, new_section: str) -> str:
    text = readme.read_text(encoding="utf-8")
    start = text.find(START_MARKER)
    end = text.find(END_MARKER)
    if start == -1 or end == -1:
        raise RuntimeError("Markers not found in README.md")
    before = text[: start + len(START_MARKER)]
    after = text[end:]
    return before + "\n\n" + new_section + "\n" + after


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--write", action="store_true", help="Write changes to README.md")
    args = parser.parse_args()
    section = generate_section()
    if args.write:
        new_text = replace_section(README, section)
        README.write_text(new_text, encoding="utf-8")
        print(f"Updated {README}")
    else:
        print(section)


if __name__ == "__main__":
    main()
